dp를 언제 적용해야할까???

(1)divide and conquer로 하나의 문제를 풀때 여러 작은 소문제로 해결할 수 있다고 판단될때.
-->주로 recursive한 구조가 발견될때.
(2)하지만 mergesort와 같은 문제와 다르게 작은 소문제들을
	일정 index 값에 따라 정의할 수 있고 그 소문제들을 모두 먼저 계산함으로서
	원래 문제의 답을 구할 수 있다.미리 정의하여 그것들의 값을 구하여 배열에 기록하는 것이
(3)이때, 주의 할점은 dp를 사용하지 않을때보다 사용할때 처리해야하는 경우의 수가 적어져야하고 그에 따라
	시간복잡도에서 이득을 볼 수 있는 경우를 판단하여 dp를 적용해야한다.



dp를 어떻게 적용해야 할까???
(1)dp로 문제를 풀기로 정했으면 일단 무엇을 기준으로 소문제를 정의 할지 결정해야한다.
	보통 결정의 기준은 다양할 수 있지만 앞선예제에서 본것처럼 특정 노드, 저울 과 같은 선택권
	이 n개 있을때 n개 모두 선택할 수 있는경우가 원래 문제라고 한다면, 그보다 적게 선택할 수 있는
	경우를 소문제로 정의하면 된다.
	%%이때 주의할점은 소문제에서 n-1개의 선택지가 있는 소문제에 대해 모든 경우를 다 계산하는 것이 아니라
	그냥 n 번째 노드를 특정하여 그 노드가 있는 경우 와 없는 경우로 나누어 n-1개의 선택지가 있는 경우는
	n 번째 노드가 없다고 가정해도 상관없다는 것이다. 그 이유는 소문제에서 모든 경우의 수를 계산하지 않아도
	대문제의 결과를 얻는 것에는 문제가 없기 때문이다.

(2)다음은 dp를 기록하는 배열을 정의해야한다. 
	1.보통 2차원 배열로 구성되며 i, 혹은 j index가 0일때가
	초기값으로 직접입력해주어야한다.-->초기값 설정을 매우 잘해야함.
	2.그 후 recursion을 사용할수도 있고 for를 이용할 수도 있는데,
	2-1 recursion의 경우 배열에 구하려는 값이 있는지 먼저 체크를 한후 있으면 그대로 사용하고
		없으면 함수 call을 recursive 하게 하여 devide함. 그후 conquer하는 상황은 역으로 초기값으로
		정의해놓은 i,j 가 0일때부터 시작하여 conquer가 시작됨.


	2-2 반복문의 경우 recursion과 다르게 divide 할 필요없이 바로 conquer하면 되는데 이 conquer를
		for 문의 순서를 통하여 조절하여야하기 때문에 실수 하기 쉬울 수 있음.
		for 문의 순서는 소문제를 정의하는 노드 혹은 저울등의 선택지 개수가 늘어나는 것을 먼저 하고 
		그 다음에 다른것들을 for 문으로 넣음 그러면 배열이 한줄씩 채워짐.
		for 문을 편하게 돌리기 위해서는 선택할 수 있는 노드 배열에서 arr[0]에 쓰레기 값을 넣어 arr[1]부터
		진짜 선택의 후보가 되는 첫번째를 1 index 에 위치하게 함.
		첫번재 for 문의 i 값은 1~i 까지의 노드를 선택할 수 있음을 의미함.

(3)만약 dp결과의 경로를 알고 싶은 경우 
	3-1) recursion 의 경우 recur 함수에서 conquer 할때의 값을 배열에 저장하여 경로를 알아냄. 
		(devide 하여 recursive call 할 때가 아니라 return 값을 결정할때 경로가 구해짐.)
	3-2) iteration의 경우 어처피 conquer 만 하므로 배열에 i,j 가 정해질때 새로운 배열 p[][]에 0,1,2...를
	분기조건에 따라 넣음으로서 찾을 수 있음.

	-->결론은 memoization 한 배열과 동일한 구조의 배열을 하나 설정하여 분기 조건에 따라 값을 넣게 만들면 찾을 수 있음.

	


